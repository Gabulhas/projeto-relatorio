


\chapter{Implementação}
\label{chap:imp}

\section{Introdução}
\label{chap4:sec:intro}


\section{Escolhas de Implementação}
\label{chap4:escolhas_implementacao}
% Explicar o uso das bibliotecas
% Pôr a visualização à parte
% Explicar o uso de pedidos HTTP (por ser um contexto distribuido, e HTTP ser um dos protocolos mais usados
% Explicar uso de Containers Docker

\section{Detalhes de Implementação}
% problemas da concorrência
% Explicar a divisão em Modulos e em ficheiros
% referir o uso de um Mutex global
% referir o uso de um objeto ``SelfNode''

\section{Classe \emph{Node}}
A Classe \emph{Node} desempenha a função de armazenar o estado atual do próprio \emph{Node}, define os métodos/procedimentos que este pode executar, e uma enumeração dos 5 diferentes tipos de \emph{Nodes}.



Nesta Implementação, esta classe está incluída num módulo \emph{Go} ``Nodes'' (Ou seja, num diretório com o mesmo nome), e é constituído por 5 ficheiros, sendo que as várias (funcionalidades ?) estão distribuídas por estes ficheiros.

Estes são:
\begin{itemize}
    \item Node.go - Contém \emph{Struct} que define os \textbf{atributos}.
    \item NodeBehaviours.go - Define os possíveis \textbf{comportamentos}.
    \item NodeCommunications.go - Conjunto de \textbf{métodos de comunicação} de informação para outros \emph{Nodes}.
    \item NodeTranformations.go - \textbf{Transformações}/Mudanças de tipo que o \emph{Node} pode sofrer.
    \item NodeType.go - Enumeração dos \textbf{tipos} que o \emph{Node} pode ser.
\end{itemize} 


\section{Atributos da Classe}
Como referido no capítulo de Especificação, um \emph{Node} tem, no máximo 5 atributos, no entanto, na sua implementação este incluí no total 8, tendo a mais os atributos ``MyAddress'', ``Type'' e ``VisAddress''.
Esta é a definição da \emph{Struct} dos atributos do \emph{Node}.


Este código está presente no ficheiro Node.go.


\begin{lstlisting}[caption={Definição da estrutura \emph{Node}},language=Go]
type Node struct {
	Type       NodeType //Tipo do Node, ver Tipos de Nodes
	MyChan     string   //Channel onde recebe acesso ao objeto
	Find       string   //Channel onde recebe pedidos
	Link       string   //Ligacao para o child Node
	WaiterChan string   //Channel do Node que esta na posicao seguinte da fila
	MyAddress  string   //Endereco do Node
	VisAddress string   //Endereco para onde envia o seu estado atual para a atualizacao da visualizacao
	Obj        bool     //Se tem objeto ou nao 
}

\end{lstlisting}
Na \emph{Struct} estão definidos todos os atributos que o \emph{Node} pode ter, porém, quando um atributo é inexistente, este é definido como vazio, ou seja, os atributos ``WaiterChan'', ``VisAddress'' e ``Link'' podem ser \emph{strings} vazias.

O atributo \textbf{``MyChan''} é o \emph{Channel} do \emph{Node} onde este vai receber o acesso ao objeto.
Também é usado na construção da \emph{Struct} que irá ser enviada para o \emph{Child} node quando este decide pedir o acesso ao objeto.

O atributo \textbf{``Find''} é o \emph{Channel} do \emph{Node} onde este vai receber pedidos de acesso de outros \emph{Nodes}. 
Também é usado na construção dos dois tipos de pedidos, no pedido de \emph{AccessRequest} quando o \emph{Node} decide fazer um pedido e quando este reencaminha um pedido para o \emph{Child Node}, ao construir um novo pedido de \emph{AccessRequest}, mantendo o ``WaiterChan'' mas substituindo o ``Link'' do pedido pelo seu ``Find''.

O atributo \textbf{``Link''} é o \emph{Channel ``Find''} do \emph{Child Node}. Pode existir ou não, caso não exista este é representado como uma \emph{string} vazia.
Este é usado para o reencaminhamento e difusão de quaisquer pedidos ``AccessRequest'', quer estes sejam construídos pelo \emph{Node} ou pedidos que chegaram ao seu ``Find''.

O atributo \textbf{``WaiterChan''} é o \emph{Channel ``MyChan''} do \emph{Node} que espera pelo acesso ao objeto. Pode existir ou não, caso não exista este é representado como uma \emph{string} vazia.
Este é usado na atribuição do objeto ao \emph{Node} que está à espera do acesso ao objeto, por parte do \emph{Node}.

O atributo \textbf{``MyAddress''} é o endereço \acs{IP} do próprio Node. 
Este é usado para identificação do \emph{Node} na rede e para a construção dos \emph{Channels ``Find''} e \emph{``MyChan''},
pois este é usado na inicialização do servidor \acs{HTTP} do \emph{Node}.

O atributo \textbf{``VisAddress''} é o \acs{URL} usado para a atualização do estado do \emph{Node} na visualização.

O atributo \textbf{``Obj''} apenas indica se o \emph{Node} tem acesso ou não ao objeto.
Este atributo é redundante, pois a mesma informação pode ser adquirida a partir do tipo do node (``Type''), 
em que, caso o \emph{Node} seja do tipo \emph{OwnerTerminal} ou \emph{OwnerWithRequest}, este tem o acesso ao objeto.

\section{Inicialização do objeto ``Self Node''}

\section{Tipos de Nodes}
\label{chap:imp:node:tipos}



\section{Comportamentos}
Como referido no capítulo de Especificação \ref{especificacao:atr:section}, 
o \emph{Node} pode ter vários comportamentos, 
que dependem do seu tipo e de fatores que os desencadeiam, como por exemplo receber um pedido de acesso ou o acesso ao objeto e 
o próprio \emph{Node} (no caso desta implementação) tomar decisões, como ceder o acesso ao objeto ou pedir o mesmo.

Este código está presente no ficheiro NodeBehaviours.go .

\subsection{Receção de um pedido Access Request}
Todos os tipos de \emph{Nodes} têm a possibilidade de receber um pedido de \emph{AccessRequest}, no entanto, o comportamento (e transformação) desencadeado por este evento é diferente entre tipos.

% Referir a outra secção
Quando o \emph{Node} recebe um pedido \emph{Access Request} (\emph{Handler} ``findRoute'' no ficheiro ``controller.go'') o
e método ``HandleFind'' da classe \emph{Node} é executado.
O objeto de entrada provêm da descodificação dos dados transmitidos pelo \emph{Parent Node}.

Na implementação deste método, foi usada a estrutura condicional ``Switch'' para escolher que comportamento será tomado 
dependendo do tipo atual do ``selfNode''.

% Referir a outra secção
O acesso à secção crítica deste método é sincronizada com o uso do \emph{Mutex} ``Mutex'', isto é,
o acesso ao estado atual do ``selfNode'' só é adquirido por uma \emph{goroutine} de cada vez.

O pedido de \emph{Access Request} recebido, ``accessRequest'' é copiado para um novo objeto ``newAccessRequest'',
quer irá ser utilizado na construção de um novo ``AccessRequest'',
caso o \emph{Node} redirecione o pedido para o seu \emph{Child Node}.

% Referir a outra secção
O último procedimento a ser executado neste método é o método ``UpdateVisualization'' da classe ``Node'', em uma nova \emph{goroutine}.
Este método é usado para atualizar o estado atual do \emph{Node} na visualização.

\begin{lstlisting}[caption={\emph{Switch} de decisão do comportamento.},language=Go]
Mutex.Lock() // fecho do Mutex
defer Mutex.Unlock() // a primitiva defer indica que o codigo de abertura do Mutex sera corrido caso a execucao deste metodo termine

newAccessRequest := accessRequest // copia do pedido

// Decisao do comportamento que depende do tipo "Type" atual do Node
switch node.Type {
	case OWNER_TERMINAL:
	case OWNER_WITH_REQUEST:
	case IDLE:
	case WAITER_TERMINAL:
	case WAITER_WITH_REQUEST:
	}
go node.UpdateVisualization()
\end{lstlisting}

Será feita uma descrição do comportamento que cada tipo de \emph{Node} pode ter,
isto é, a implementação de cada caso do ``Switch''.

\subsubsection*{Caso OWNER\textunderscore TERMINAL}
% Referir a outra secção
Caso o tipo seja ``OWNER\textunderscore TERMINAL'', o \emph{Node}, o método ``OwnerWithRequest'' da classe \emph{Node} irá ser executado, que transforma o 
\emph{Node} em \emph{Owner With Request}.

Os parâmetros de entrada desse método serão o ``Link'' e ``WaiterChan'' (do atributo ``GiveAccess'' do pedido), que correspondem ao ``Find'' do \emph{Parent Node} e ao ``MyChan'' do \emph{Node} que fez o pedido, respetivamente.
Isto é, a ligação entre o \emph{Node} e o transmissor do pedido inverte-se, e o \emph{Node} passa a ter um \emph{Node} em espera.

% Referir a outra secção
Após a transformação, será executado o método ``releaseObj'' do \emph{Node}, que irá despoletar o comportamento de Cedência do Objeto, em uma nova \emph{goroutine}.


\begin{lstlisting}[caption={Comportamento do \emph{Node} tipo \emph{Owner Terminal} caso receba um pedido \emph{Access Request} no \emph{Channel ``Find''}},language=Go]
node.OwnerWithRequest(accessRequest.Link, accessRequest.GiveAccess.WaiterChan) // transfomacao em Owner With Request
go node.releaseObj() //comportamento de Cedencia do Objeto
\end{lstlisting}



\subsubsection*{Caso OWNER\textunderscore WITH\textunderscore REQUEST}
Caso o tipo seja ``OWNER\textunderscore WITH\textunderscore REQUEST'',
o Atributo ``Link'' do objeto ``newAccessRequest'' será substituído pelo ``Find'' do \emph{Node}, para o seu \emph{Child Node} inverter a ligação.

Após feita esta alteração do objeto, o \emph{Node} envia o objeto ``newAccessRequest'' pelo seu ``Link'' para o seu \emph{Child Node}.

Por último, o método ``OwnerWithRequest'' da classe \emph{Node} irá ser executado, em que o \emph{Node} mantém o tipo mas
é feita uma alteração do seu ``Link'' para o ``Find'' que provêm do pedido ``Access Request'' que recebeu, isto é, para o ``Find'' do seu \emph{Parent Node}, 
invertendo a ligação,
mas mantendo o \emph{WaiterChan} porque o \emph{Node} que fez o pedido ainda não tem o acesso ao objeto.


\begin{lstlisting}[caption={Comportamento do \emph{Node} tipo \emph{Owner Terminal} caso receba um pedido \emph{Access Request} no \emph{Channel ``Find''}},language=Go]
newAccessRequest.Link = node.Find
node.SendThroughLink(newAccessRequest)
node.OwnerWithRequest(accessRequest.Link, node.WaiterChan)
\end{lstlisting}



\subsubsection*{Caso IDLE}
Caso o tipo seja ``IDLE'',
o Atributo ``Link'' do objeto ``newAccessRequest'' será substituído pelo ``Find'' do \emph{Node}, para o seu \emph{Child Node} inverter a ligação.

Após feita esta alteração do objeto, o \emph{Node} envia o objeto ``newAccessRequest'' pelo seu ``Link'' para o seu \emph{Child Node}.

Por último,  método ``Idle'' da classe \emph{Node} irá ser executado, que mantém o tipo do \emph{Node}, mas
é feita a alteração do seu ``Link'' para o ``Find'' que provêm do pedido ``Access Request'' que recebeu, ou seja, para o ``Find'' do seu \emph{Parent Node}, 
que inverte a ligação.


\begin{lstlisting}[caption={Comportamento do \emph{Node} tipo \emph{Owner Terminal} caso receba um pedido \emph{Access Request} no \emph{Channel ``Find''}},language=Go]
newAccessRequest.Link = node.Find
node.SendThroughLink(newAccessRequest)
node.OwnerWithRequest(accessRequest.Link, node.WaiterChan)
\end{lstlisting}


\subsubsection*{Caso WAITER\textunderscore TERMINAL}
Caso o tipo seja ``WAITER\textunderscore TERMINAL'', o \emph{Node} o método ``WaiterWithRequest'' do \emph{Node} será executado,
que transforma o \emph{Node} em \emph{WAITER\textunderscore WITH \textunderscore REQUEST}.

Os parâmetros de entrada são o ``Link'' e ``WaiterChan'' (do atributo ``GiveAccess'' do pedido), que correspondem ao ``Find'' do \emph{Parent Node} e ao ``MyChan'' do \emph{Node} que fez o pedido, respetivamente.
O ``Link'' é o ``Find'' do \emph{Parent Node}, o que causa a inversão da ligação.

\begin{lstlisting}[caption={Comportamento do \emph{Node} tipo \emph{Owner Terminal} caso receba um pedido \emph{Access Request} no \emph{Channel ``Find''}},language=Go]
node.WaiterWithRequest(accessRequest.Link, accessRequest.GiveAccess.WaiterChan)
\end{lstlisting}


\subsubsection*{Caso WAITER\textunderscore WITH \textunderscore REQUEST}	
Caso o tipo seja ``WAITER\textunderscore WITH \textunderscore REQUEST'', o Atributo ``Link'' do objeto ``newAccessRequest'' será substituído pelo ``Find'' do \emph{Node},
para que o \emph{Child Node} possa inverter a sua ligação.

Após feita esta alteração do objeto, o \emph{Node} envia o objeto ``newAccessRequest'' pelo seu ``Link'' para o seu \emph{Child Node}.

Por último, este sofre uma transformação. O método ``WaiterWithRequest'' da classe \emph{Node} irá ser executado, 
em que é feita uma alteração do seu ``Link'' para o ``Find'' que provêm do pedido ``Access Request'' que recebeu, ou seja, para o ``Find'' do seu \emph{Parent Node}, 
mas mantêm o \emph{WaiterChan} porque o \emph{Node} que fez o pedido ainda não tem o acesso ao objeto.
O ``Link'' é o ``Find'' do \emph{Parent Node}, o que causa a inversão da ligação.

\begin{lstlisting}[caption={Comportamento do \emph{Node} tipo \emph{Owner Terminal} caso receba um pedido \emph{Access Request} no \emph{Channel ``Find''}},language=Go]
newAccessRequest.Link = node.Find // Alteracao do atributo Find do objeto newAccessRequest para o Find do Node
node.SendThroughLink(newAccessRequest) // Envio do objeto newAccessRequest pelo link
node.WaiterWithRequest(accessRequest.Link, node.WaiterChan) //transformacao do Node. Mantem-se o WaiterChan mas altera-se o Link
\end{lstlisting}

\subsection{Cedência do Objeto}
No caso do \emph{Node} ser do tipo ``WAITER\textunderscore TERMINAL'' e receber um pedido ``Access Request'', 
este sofre uma transformação, muda de tipo para ``WAITER\textunderscore WITH\textunderscore REQUEST'' e passou a deter o atributo ``WaiterChan'' (``MyChan'' do \emph{Node} que fez o pedido).

% forma como esta frase está construída pode não estar bem
Esta secção de código é executada concorrentemente (numa \emph{goroutine}) com qualquer outras \emph{goroutines} 
que estejam a ser executadas,
isto para permitir que o \emph{Node} receba outros pedidos,
que os transmita, e que outros comportamentos ou transformações possam ocorrer 
enquanto este espera para ceder o acesso, isto é, enquanto que o \emph{Node} é ``OWNER\textunderscore WITH\textunderscore REQUEST''.


Referente a um caso real, o \emph{Node} transmitiria o objeto pelo \emph{Channel ``WaiterChan''}, quando, por exemplo, 
o acesso a este não fosse mais necessário.
No entanto, por questões de se pretender criar uma simulação deste protocolo, o \emph{Node} decide ceder o acesso ao objeto após um tempo aleatório (entre 1 a 2 segundos)
depois de receber o pedido para o seu acesso.

É executada a primitiva ``defer'' com o método ``Unlock'' do objeto ``Mutex'' para,
quando esta função terminar, o \emph{Mutex} ser desbloqueado, para que outras \emph{goroutines}
possam aceder ao estado atual do objeto.

\begin{lstlisting}[caption={\emph{Node} espera 1 ou 2 segundos antes de ceder o objeto.},language=Go]
	defer Mutex.Unlock() // o ``Mutex'' e desbloqueado quando a execucao deste metodo terminar
	randomSleep := utils.RandomRange(1, 2) // Gera um numero aleatorio, neste caso, 1 ou 2
	time.Sleep(time.Second * time.Duration(randomSleep)) // A \emph{goroutine} espera durante o tempo aleatorio gerado (em segundos)
\end{lstlisting}

De seguida é criado um objeto da classe/tipo ``GiveAccess'' que será transmitido para o \emph{Node} em espera 
através do ``WaiterChan''.

\begin{lstlisting}[caption={Criação do objeto ``accessObject'', da classe ``GiveAccess''},language=Go]
	accessObject := Channels.GiveAccess{WaiterChan: node.WaiterChan}
\end{lstlisting}


Este método (``releaseObj''), contém uma secção crítica,
pois acede ao objeto ``selfNode''. 
O acesso à secção crítica deste método é sincronizada com o uso do \emph{Mutex} ``Mutex'', ou seja,
o acesso ao estado atual do ``selfNode'' só é adquirido por uma \emph{goroutine} de cada vez, para prevenir a alteração do estado
enquanto que o \emph{Node} transmite o acesso ao objeto, 
e para que a transformação (método ``Idle'') ocorra de seguida ao \emph{Node} deixar de ter o acesso ao objeto.

%Referir sendObjectAccess
Quando tiver a possibilidade de aceder à secção crítica, este irá transmitir o acesso do objeto ao \emph{Node} em espera.
De seguida, como já não possui o acesso ao objeto, este sofre um transformação, mudando-se para um \emph{Node}
do tipo ``IDLE'', mantendo o ``Link''.

Como o \emph{Node} transformou-se em ``IDLE'', é inicializada uma \emph{goroutine} que executará o método ``AutoRequest''.
Este método desempenha a função de decidir se o \emph{Node} faz um pedido de acesso. 
%Referir mais à frente o autoRequest
No entanto, este é descrito num capítulo diferente.

De seguida, o procedimento a ser executado neste método é o método ``UpdateVisualization'' da classe ``Node'',
em uma nova \emph{goroutine}.
Este método é usado para atualizar o estado atual do \emph{Node} na visualização.


\begin{lstlisting}[caption={Acesso à secção crítica, transmição do Objeto, transformação em \emph{Node} ``IDLE'', \emph{goroutine} de decisão de pedido, e atualização na visualização},language=Go]
	Mutex.Lock() //Pedido de acesso a seccao critica
	node.SendObjectAccess(accessObject) //Transmissao do objeto, atraves do envio do objeto ``accessObject''
	node.Idle(node.Link) //transformacao em ``IDLE'', mas mantendo o ``Link''
	go node.AutoRequest() // goroutine que decidira se o \emph{Node} faz um pedido de acesso
	go node.UpdateVisualization() // atualiza o estado do Node na visualizacao

\end{lstlisting}


\subsection{Realização de um pedido de acesso}
No caso do \emph{Node} ser do tipo ``IDLE'', este tem a possibilidade de pedir o acesso ao objeto.
Qualquer outro tipo de \emph{Node} não pode fazer pedidos de acesso.

Neste método há acesso ao estado atual do \emph{Node},
logo faz-se uso de um ``Mutex'' para o acesso ser sincronizado.

Como, a partir da visualização e da ``Shell'' do \emph{Node} é possível forçar o \emph{Node} 
a realizar um pedido, quando a \emph{goroutine} acede à secção crítica do método (acesso ao estado atual do \emph{Node})
é verificado se o tipo do \emph{Node} é ``IDLE''.


% Linguagem de Web pode estar incorreta
Caso seja do tipo ``IDLE'', irá ser instanciado um objeto do tipo ``Channels.AccessRequest'', em que o atributo
``Link'' contém o \emph{Channel ``Find''}  do próprio \emph{Node}, ou seja, o \acs{URL} do método
onde o \emph{Node} recebe os pedidos ``AccessRequest'', e
o atributo "GiveAccess" (do tipo ``Channels.GiveAccess''), que contém o \emph{Channel ``MyChan''} do próprio
\emph{Node}, o \acs{URL} do método
onde o \emph{Node} recebe o acesso ao objeto.
Depois da instanciação, é executado o método ``SendThroughLink'' do \emph{Node}, que envia o objeto 
pelo ``Link'' do \emph{Node} para o seu \emph{Child Node}.

O ``Link'' deste objeto servirá para o \emph{Child Node} do \emph{Node} inverter a ligação, isto é, 
para que o \emph{Child Node} possa fazer a ligação de volta para o \emph{Node}.

O atributo ``GiveAccess'' será usado pelo próximo \emph{Node} \emph{Terminal} (quer este seja \emph{Owner} ou \emph{Waiter}), 
para quando esse próximo \emph{Node} obtiver acesso ao objeto, este redirecioná-lo para o \emph{Node} que realizou o pedido.

Como o \emph{Node} realizou um pedido de acesso e espera pelo acesso ao objeto, este transforma-se em 
``WAITER\textunderscore TERMINAl'', deixando de ter ``Link''.

Por último, o \emph{Node} atualiza o seu estado na visualização em uma nova \emph{goroutine}.


\begin{lstlisting}[caption={Método ``Request''},language=Go]
func (node *Node) Request() {
	Mutex.Lock() // Sincronizacao do acesso a seccao critica
	defer Mutex.Unlock() // O metodo ``Unlock'' do objeto ``Mutex'' sera executado caso o metodo ``Request'' termine

	//Existe para evitar:
	//que ou o utilizador faca um request e o node ja mudou de tipo
	//que se faca um request a partir do metodo do Node de pedidos remotos
	if node.Type != IDLE {
		fmt.Printf("Can't request an object if not Idle.")
		return
	}
	fmt.Printf("Requesting.")

	//Instanciacao do pedido de acesso
	accessRequest := Channels.AccessRequest{
		GiveAccess: Channels.GiveAccess{
			WaiterChan: node.MyChan,
		},
		Link: node.Find,
	}

	//Envio do pedido de acesso
	node.SendThroughLink(accessRequest)


	//transfomacao em WaiterTerminal, visto que este espera pelo acesso
	node.WaiterTerminal()

	//atualizacao do estado atual do Node na visualizacao
	go node.UpdateVisualization()
}
\end{lstlisting}


É possível o utilizador provocar a realização do pedido pelo \emph{Node}. Pode ser feito a partir de uma 
``Shell'' que é iniciada com o programa,
ou através da visualização, ao clicar duas vezes no \emph{Node} do grafo correspondente ao \emph{Node} em questão.

No entanto, por questões de simulação do diretório, caso o estado inicial do \emph{Node}
ou este mude de tipo para ``IDLE'', 
é iniciada uma \emph{goroutine} que executa o método ``AutoRequest'' da classe \emph{Node}.

Neste método existe um ciclo ``infinito'', cuja a única condição de saída é o \emph{Node} realizar o pedido.

A cada ciclo é gerado um valor aleatório, que será, em segundos, o tempo que esta \emph{goroutine} irá esperar.

Após a espera, um outro valor aleatório é gerado (0 ou 1),
que indicará se o \emph{Node} irá fazer um pedido (ou seja, se será executado o método ``Request'' da classe ``Node'').


Caso faça o pedido (seja o valor 1), o ciclo irá terminar.
Caso contrário, o \emph{Node} terá de esperar um tempo aleatório até ao próximo ciclo.

\begin{lstlisting}[caption={Método ``AutoRequest''},language=Go]
func (node *Node) AutoRequest() {
	var randomSleep int

	// Ciclo infinito
	for {

		randomSleep = utils.RandomRange(5, 15) // E gerado um numero inteiro aleatorio entre 5 e 15

		fmt.Printf("\nTrying to Request the Object in %d seconds.", randomSleep)


		// A \emph{goroutine} espera durante o valor de ``randomSleep'' (em segundos)
		time.Sleep(time.Second * time.Duration(randomSleep))

		//E gerado um numero inteiro, 0 ou 1.
		//Caso o valor seja 1, o \emph{Node} ira realizar um pedido de acesso e o ciclo termina
		if requests := utils.RandomRange(0, 1); requests > 0 {
			node.Request()
			break
		} else {
			//Caso seja 0, o \emph{Node} ira gerar um numero inteiro aleatorio entre 5 e 20
			cooldown := utils.RandomRange(5, 20)
			fmt.Printf("Didn't request. Retrying in %d seconds.", cooldown)
			// A \emph{goroutine} espera durante o valor de ``cooldown'' (em segundos)
			time.Sleep(time.Second * time.Duration(cooldown))
		}
	}

}
\end{lstlisting}
Este método permite que \emph{Node} realize pedidos em tempo aleatório com uma chance de 50\%,
ou seja, há a possibilidade de o \emph{Node} não realizar um pedido.


\subsection{Receção acesso ao objeto}
Caso o \emph{Node} seja do tipo \emph{WAITER\textunderscore TERMINAL} ou \emph{WAITER\textunderscore WITH\textunderscore REQUEST}
este pode receber o acesso ao objeto.

Quando o \emph{Node} recebe um pedido \emph{GiveAccess} (\emph{Handler} ``myChanRoute'' no ficheiro ``controller.go'') o
método ``ReceiveObj'' da classe \emph{Node} é executado.
O objeto de entrada do método provêm da descodificação dos dados transmitidos pelo \emph{Owner}
que cedeu o acesso ao objeto, isto é, uma desserialização dos dados provenientes de um método \acs{HTTP} ``POST''
num objeto do tipo ``GiveAccess''.


Como neste método, é feito um acesso ao estado atual do \emph{Node} e há transformações, 
o acesso a esta secção crítica é sincronizada com o uso de um \emph{Mutex}.
Para tal, é executado o método ``Lock'' do objeto ``Mutex''.
No fim da execução deste método é necessário desbloquear o ``Mutex'', para tal 
a primitiva ``defer'' é usada, que executará o método ``Unlock'' do objeto ``Mutex''.

Como este programa se trata de uma simulação, este objeto não tem qualquer uso,
no entanto, num caso de uso,
este objeto seria um \emph{Channel} de comunicação com um ficheiro/base de dados, ou qualquer outro
objeto em que o seu acesso seria sincronizado.


Quando o \emph{Node} é ``WAITER\_TERMINAL'', ao receber o acesso ao objeto,
este transforma-se em ``OWNER\_TERMINAL'', pois não tem nenhum outro \emph{Node} em espera.


Quando o \emph{Node} é ``WAITER\_WITH\_Request'', ao receber o acesso ao objeto,
este transforma-se em ``OWNER\_WITH\_REQUES'', pois ainda tem outro \emph{Node} em espera.
%Referir capitulo do release.
Com o \emph{Node} tem outro \emph{Node} à espera do acesso, é inicializada uma \emph{goroutine}
que irá executar o método ``releaseObj'' da classe \emph{Node}.


Ao final, é inicializada uma \emph{goroutine} que executará 
o método ``UpdateVisualization'', para que o estado do \emph{Node}
seja atualizado na visualização.


\begin{lstlisting}[caption={Método ``AutoRequest''},language=Go]

func (node *Node) ReceiveObj(giveAccess Channels.GiveAccess) {
	Mutex.Lock() // Sincronizacao do acesso a seccao critica
	defer Mutex.Unlock() // O metodo ``Unlock'' do objeto ``Mutex'' sera executado caso o metodo ``Request'' termine

	fmt.Printf("Received Access:")
	fmt.Println(giveAccess)
	switch node.Type {
	case WAITER_TERMINAL:
		node.OwnerTerminal()
		break
	case WAITER_WITH_REQUEST:
		node.OwnerWithRequest(node.Link, node.WaiterChan)
		go node.releaseObj()
		break
	}

	go node.UpdateVisualization()

}

\end{lstlisting}

\section{Transformações do \emph{Node}}

% possivelmente adicionar diagrama para ficar mais completo
% por exemplo, IDLE -> recebeu pedido -> IDLE (mas muda o LINK)
% ou, OWNER -> cedeu o objeto -> IDLE(deixou de ter WaiterChan)


Neste capítulo serão descritas as transformações que o \emph{Node}
pode sofrer, tais como as suas implementações.


% mudar o executa qualquer comportamento
O \emph{Node} sofre transformações quando este executa qualquer comportamento, 
no entanto, uma transformação não significa uma mudança de tipo,
mas uma mudança de estado.

Estas são as possíveis transformações que o \emph{Node} pode sofrer:

\begin{figure}[!htb]
\centering
\includegraphics[width=500pt]{state-diagram.png}
\caption{Diagrama de Estados do \emph{Node}}
Nota: O estado inicial do \emph{Node} não está presente porque este pode começar em qualquer estado/tipo.
\end{figure}


O nome dos métodos das transformações provêm do nome to tipo 
para o qual se vai mudar ou manter.


\subsubsection*{Idle}
Se o \emph{Node} é do tipo ``IDLE'' e este recebe um pedido de acesso, após transmitir
o pedido para o seu \emph{Child Node}, sofre a transformação ``Idle'' (mantém o tipo) mas atualiza o \emph{Link} para o \emph{Find} do seu \emph{Parent Node}.
O novo ``Link'' (``NewLink'') é o parâmetro de entrada deste método.

Se o \emph{Node} é do tipo ``OWNER\_WITH\_REQUEST'' mas cedeu o acesso ao objeto, visto que este já não o possui o \emph{Node}
transforma-se em ``IDLE'', mas mantém o \emph{LINK}, isto é, o seu ``Link'' atual é usado como
parâmetro de entrada deste método.

\begin{lstlisting}[caption={Método/transformação ``Idle''},language=Go]
func (node *Node) Idle(newLink string) {
	node.Type = IDLE    //Alteracao do tipo para ``IDLE''
	node.Link = newLink //Atualizacao do ``Link''
	node.Obj = false    //Caso seja ``OWNER\_WITH\_REQUEST'', deixa de ter acesso ao obj
	node.WaiterChan = ""//Caso seja ``OWNER\_WITH\_REQUEST'', deixa de ter o ``Node'' em espera
}
	
\end{lstlisting}


\subsubsection*{WaiterTerminal}

Se o \emph{Node} é do tipo ``IDLE'' e realizar um pedido de acesso,
este transforma-se em ``WAITER\_TERMINAL''.
Como foi o \emph{Node} que realizou o pedido de acesso, este não aponta para nenhum outro \emph{Node} (o ``Link'' passa a vazio/nulo).


\begin{lstlisting}[caption={Método/transformação ``Idle''},language=Go]
func (node *Node) WaiterTerminal() {
	node.Type = WAITER_TERMINAL //Alteracao do tipo para ``WAITER\_TERMINAL''
	node.Link = ""       // Como foi o \emph{Node} quem realizou o pedido, este nao aponta para nenhum outro \emph{Node}
	node.WaiterChan = "" //redundante
}
\end{lstlisting}



\subsubsection*{OwnerTerminal}

Se o \emph{Node} é do tipo ``WAITER\_TERMINAL'' e receber o acesso ao objeto, como
não recebeu qualquer pedido, este mantém-se sem ``Link'' ou ``WaiterChan'', 
mas transforma-se em ``OWNER\_TERMINAL''.

\begin{lstlisting}[caption={Método/transformação ``Idle''},language=Go]
func (node *Node) OwnerTerminal() {
	node.Type = OWNER_TERMINAL //Alteracao do tipo para ``OWNER\{_}TERMINAL''
	node.Link = ""             
	node.Obj = true			   //Como se transformou em ``OWNER\{_}TERMINAL'' significa que passou a deter o acesso ao objeto
	node.WaiterChan = ""       //Redundante, mas um \emph{Node} deste tipo nao tem \emph{Node} a espera do acesso ao objeto

}
\end{lstlisting}




\section{Comunicação entre Nodes}
\section{Classes de \emph{Channels}}



\section{Implementação da Visualização}
% como os dados são atualizados
% como os dados são passados para a página
% como os dados são demonstrados no grafo
% como a queue é formada
% como o histórico é formado

\section{Conclusões}
