


\chapter{Implementação}
\label{chap:imp}

\section{Introdução}
\label{chap4:sec:intro}


\section{Escolhas de Implementação}
\label{chap4:escolhas_implementacao}
% Explicar o uso das bibliotecas
% Pôr a visualização à parte
% Explicar o uso de pedidos HTTP (por ser um contexto distribuido, e HTTP ser um dos protocolos mais usados
% Explicar uso de Containers Docker

\section{Detalhes de Implementação}
% problemas da concorrência
% Explicar a divisão em Modulos e em ficheiros
% referir o uso de um Mutex global
% referir o uso de um objeto ``SelfNode''

\section{Classe \emph{Node}}
A Classe \emph{Node} desempenha a função de armazenar o estado atual do próprio \emph{Node}, define os métodos/procedimentos que este pode executar, e uma enumeração dos 5 diferentes tipos de \emph{Nodes}.



Nesta Implementação, esta classe está incluída num módulo \emph{Go} ``Nodes'' (Ou seja, num diretório com o mesmo nome), e é constituído por 5 ficheiros, sendo que as várias (funcionalidades ?) estão distribuídas por estes ficheiros.

Estes são:
\begin{description}
    \item [Node.go] - Contém \emph{Struct} que define os \textbf{atributos}.
    \item [NodeBehaviours.go] - Define os possíveis \textbf{comportamentos}.
    \item [NodeCommunications.go] - Conjunto de \textbf{métodos de comunicação} de informação para outros \emph{Nodes}.
    \item [NodeTranformations.go] - \textbf{Transformações}/Mudanças de tipo que o \emph{Node} pode sofrer.
    \item [NodeType.go] - Enumeração dos \textbf{tipos} que o \emph{Node} pode ser.
\end{description} 


\section{Atributos da Classe}
Como referido no capítulo de Especificação, um \emph{Node} tem, no máximo 5 atributos, no entanto, na sua implementação este incluí no total 8, tendo a mais os atributos ``MyAddress'', ``Type'' e ``VisAddress''.
Esta é a definição da \emph{Struct} dos atributos do \emph{Node}.


Este código está presente no ficheiro Node.go.


\begin{lstlisting}[caption={Definição da estrutura \emph{Node}},language=Go]
type Node struct {
	Type       NodeType //Tipo do Node, ver Tipos de Nodes
	MyChan     string   //Channel onde recebe acesso ao objeto
	Find       string   //Channel onde recebe pedidos
	Link       string   //Ligacao para o child Node
	WaiterChan string   //Channel do Node que esta na posicao seguinte da fila
	MyAddress  string   //Endereco do Node
	VisAddress string   //Endereco para onde envia o seu estado atual para a atualizacao da visualizacao
	Obj        bool     //Se tem objeto ou nao 
}

\end{lstlisting}
Na \emph{Struct} estão definidos todos os atributos que o \emph{Node} pode ter, porém, quando um atributo é inexistente, este é definido como vazio, ou seja, os atributos ``WaiterChan'', ``VisAddress'' e ``Link'' podem ser \emph{strings} vazias.

O atributo \textbf{``MyChan''} é o \emph{Channel} do \emph{Node} onde este vai receber o acesso ao objeto.
Também é usado na construção da \emph{Struct} que irá ser enviada para o \emph{Child} node quando este decide pedir o acesso ao objeto.

O atributo \textbf{``Find''} é o \emph{Channel} do \emph{Node} onde este vai receber pedidos de acesso de outros \emph{Nodes}. 
Também é usado na construção dos dois tipos de pedidos, no pedido de \emph{AccessRequest} quando o \emph{Node} decide fazer um pedido e quando este reencaminha um pedido para o \emph{Child Node}, ao construir um novo pedido de \emph{AccessRequest}, mantendo o ``WaiterChan'' mas substituindo o ``Link'' do pedido pelo seu ``Find''.

O atributo \textbf{``Link''} é o \emph{Channel ``Find''} do \emph{Child Node}. Pode existir ou não, caso não exista este é representado como uma \emph{string} vazia.
Este é usado para o reencaminhamento e difusão de quaisquer pedidos ``AccessRequest'', quer estes sejam construídos pelo \emph{Node} ou pedidos que chegaram ao seu ``Find''.

O atributo \textbf{``WaiterChan''} é o \emph{Channel ``MyChan''} do \emph{Node} que espera pelo acesso ao objeto. Pode existir ou não, caso não exista este é representado como uma \emph{string} vazia.
Este é usado na atribuição do objeto ao \emph{Node} que está à espera do acesso ao objeto, por parte do \emph{Node}.

O atributo \textbf{``MyAddress''} é o endereço \acs{IP} do próprio Node. 
Este é usado para identificação do \emph{Node} na rede e para a construção dos \emph{Channels ``Find''} e \emph{``MyChan''},
pois este é usado na inicialização do servidor \acs{HTTP} do \emph{Node}.

O atributo \textbf{``VisAddress''} é o \acs{URL} usado para a atualização do estado do \emph{Node} na visualização.

O atributo \textbf{``Obj''} apenas indica se o \emph{Node} tem acesso ou não ao objeto.
Este atributo é redundante, pois a mesma informação pode ser adquirida a partir do tipo do node (``Type''), 
em que, caso o \emph{Node} seja do tipo \emph{OwnerTerminal} ou \emph{OwnerWithRequest}, este tem o acesso ao objeto.

\section{Inicialização do objeto ``Self Node''}

\section{Tipos de Nodes}
\label{chap:imp:node:tipos}



\section{Comportamentos}
Como referido no capítulo de Especificação \ref{especificacao:atr:section}, 
o \emph{Node} pode ter vários comportamentos, 
que dependem do seu tipo e de fatores que os desencadeiam, como por exemplo receber um pedido de acesso ou o acesso ao objeto e 
o próprio \emph{Node} (no caso desta implementação) tomar decisões, como ceder o acesso ao objeto ou pedir o mesmo.

Este código está presente no ficheiro NodeBehaviours.go .

\subsection{Receção de um pedido Access Request}
Todos os tipos de \emph{Nodes} têm a possibilidade de receber um pedido de \emph{AccessRequest}, no entanto, o comportamento (e transformação) desencadeado por este evento é diferente entre tipos.

% Referir a outra secção
Quando o \emph{Node} recebe um pedido \emph{Access Request} (\emph{Handler} ``findRoute'' no ficheiro ``controller.go'') o
e método ``HandleFind'' da classe \emph{Node} é executado.
O objeto de entrada provêm da descodificação dos dados transmitidos pelo \emph{Parent Node}.

Na implementação deste método, foi usada a estrutura condicional ``Switch'' para escolher que comportamento será tomado 
dependendo do tipo atual do ``selfNode''.

% Referir a outra secção
O acesso à secção crítica deste método é sincronizada com o uso do \emph{Mutex} ``Mutex'', isto é,
o acesso ao estado atual do ``selfNode'' só é adquirido por uma \emph{goroutine} de cada vez.

O pedido de \emph{Access Request} recebido, ``accessRequest'' é copiado para um novo objeto ``newAccessRequest'',
quer irá ser utilizado na construção de um novo ``AccessRequest'',
caso o \emph{Node} redirecione o pedido para o seu \emph{Child Node}.

% Referir a outra secção
O último procedimento a ser executado neste método é o método ``UpdateVisualization'' da classe ``Node'', em uma nova \emph{goroutine}.
Este método é usado para atualizar o estado atual do \emph{Node} na visualização.

\begin{lstlisting}[caption={\emph{Switch} de decisão do comportamento.},language=Go]
Mutex.Lock() // fecho do Mutex
defer Mutex.Unlock() // a primitiva defer indica que o codigo de abertura do Mutex sera corrido caso a execucao deste metodo termine

newAccessRequest := accessRequest // copia do pedido

// Decisao do comportamento que depende do tipo "Type" atual do Node
switch node.Type {
	case OWNER_TERMINAL:
	case OWNER_WITH_REQUEST:
	case IDLE:
	case WAITER_TERMINAL:
	case WAITER_WITH_REQUEST:
	}
go node.UpdateVisualization()
\end{lstlisting}

Será feita uma descrição do comportamento que cada tipo de \emph{Node} pode ter,
isto é, a implementação de cada caso do ``Switch''.

\subsubsection*{Caso OWNER\textunderscore TERMINAL}
% Referir a outra secção
Caso o tipo seja ``OWNER\textunderscore TERMINAL'', o \emph{Node}, o método ``OwnerWithRequest'' da classe \emph{Node} irá ser executado, que transforma o 
\emph{Node} em \emph{Owner With Request}.

Os parâmetros de entrada desse método serão o ``Link'' e ``WaiterChan'' (do atributo ``GiveAccess'' do pedido), que correspondem ao ``Find'' do \emph{Parent Node} e ao ``MyChan'' do \emph{Node} que fez o pedido, respetivamente.
Isto é, a ligação entre o \emph{Node} e o transmissor do pedido inverte-se, e o \emph{Node} passa a ter um \emph{Node} em espera.

% Referir a outra secção
Após a transformação, será executado o método ``releaseObj'' do \emph{Node}, que irá despoletar o comportamento de Cedência do Objeto, em uma nova \emph{goroutine}.


\begin{lstlisting}[caption={Comportamento do \emph{Node} tipo \emph{Owner Terminal} caso receba um pedido \emph{Access Request} no \emph{Channel ``Find''}},language=Go]
node.OwnerWithRequest(accessRequest.Link, accessRequest.GiveAccess.WaiterChan) // transfomacao em Owner With Request
go node.releaseObj() //comportamento de Cedencia do Objeto
\end{lstlisting}



\subsubsection*{Caso OWNER\textunderscore WITH\textunderscore REQUEST}
Caso o tipo seja ``OWNER\textunderscore WITH\textunderscore REQUEST'',
o Atributo ``Link'' do objeto ``newAccessRequest'' será substituído pelo ``Find'' do \emph{Node}, para o seu \emph{Child Node} inverter a ligação.

Após feita esta alteração do objeto, o \emph{Node} envia o objeto ``newAccessRequest'' pelo seu ``Link'' para o seu \emph{Child Node}.

Por último, o método ``OwnerWithRequest'' da classe \emph{Node} irá ser executado, em que o \emph{Node} mantém o tipo mas
é feita uma alteração do seu ``Link'' para o ``Find'' que provêm do pedido ``Access Request'' que recebeu, isto é, para o ``Find'' do seu \emph{Parent Node}, 
invertendo a ligação,
mas mantendo o \emph{WaiterChan} porque o \emph{Node} que fez o pedido ainda não tem o acesso ao objeto.


\begin{lstlisting}[caption={Comportamento do \emph{Node} tipo \emph{Owner Terminal} caso receba um pedido \emph{Access Request} no \emph{Channel ``Find''}},language=Go]
newAccessRequest.Link = node.Find
node.SendThroughLink(newAccessRequest)
node.OwnerWithRequest(accessRequest.Link, node.WaiterChan)
\end{lstlisting}



\subsubsection*{Caso IDLE}
Caso o tipo seja ``IDLE'',
o Atributo ``Link'' do objeto ``newAccessRequest'' será substituído pelo ``Find'' do \emph{Node}, para o seu \emph{Child Node} inverter a ligação.

Após feita esta alteração do objeto, o \emph{Node} envia o objeto ``newAccessRequest'' pelo seu ``Link'' para o seu \emph{Child Node}.

Por último,  método ``Idle'' da classe \emph{Node} irá ser executado, que mantém o tipo do \emph{Node}, mas
é feita a alteração do seu ``Link'' para o ``Find'' que provêm do pedido ``Access Request'' que recebeu, ou seja, para o ``Find'' do seu \emph{Parent Node}, 
que inverte a ligação.


\begin{lstlisting}[caption={Comportamento do \emph{Node} tipo \emph{Owner Terminal} caso receba um pedido \emph{Access Request} no \emph{Channel ``Find''}},language=Go]
newAccessRequest.Link = node.Find
node.SendThroughLink(newAccessRequest)
node.OwnerWithRequest(accessRequest.Link, node.WaiterChan)
\end{lstlisting}


\subsubsection*{Caso WAITER\textunderscore TERMINAL}
Caso o tipo seja ``WAITER\textunderscore TERMINAL'', o \emph{Node} o método ``WaiterWithRequest'' do \emph{Node} será executado,
que transforma o \emph{Node} em \emph{WAITER\textunderscore WITH \textunderscore REQUEST}.

Os parâmetros de entrada são o ``Link'' e ``WaiterChan'' (do atributo ``GiveAccess'' do pedido), que correspondem ao ``Find'' do \emph{Parent Node} e ao ``MyChan'' do \emph{Node} que fez o pedido, respetivamente.
O ``Link'' é o ``Find'' do \emph{Parent Node}, o que causa a inversão da ligação.

\begin{lstlisting}[caption={Comportamento do \emph{Node} tipo \emph{Owner Terminal} caso receba um pedido \emph{Access Request} no \emph{Channel ``Find''}},language=Go]
node.WaiterWithRequest(accessRequest.Link, accessRequest.GiveAccess.WaiterChan)
\end{lstlisting}


\subsubsection*{Caso WAITER\textunderscore WITH \textunderscore REQUEST}	
Caso o tipo seja ``WAITER\textunderscore WITH \textunderscore REQUEST'', o Atributo ``Link'' do objeto ``newAccessRequest'' será substituído pelo ``Find'' do \emph{Node},
para que o \emph{Child Node} possa inverter a sua ligação.

Após feita esta alteração do objeto, o \emph{Node} envia o objeto ``newAccessRequest'' pelo seu ``Link'' para o seu \emph{Child Node}.

Por último, este sofre uma transformação. O método ``WaiterWithRequest'' da classe \emph{Node} irá ser executado, 
em que é feita uma alteração do seu ``Link'' para o ``Find'' que provêm do pedido ``Access Request'' que recebeu, ou seja, para o ``Find'' do seu \emph{Parent Node}, 
mas mantêm o \emph{WaiterChan} porque o \emph{Node} que fez o pedido ainda não tem o acesso ao objeto.
O ``Link'' é o ``Find'' do \emph{Parent Node}, o que causa a inversão da ligação.

\begin{lstlisting}[caption={Comportamento do \emph{Node} tipo \emph{Owner Terminal} caso receba um pedido \emph{Access Request} no \emph{Channel ``Find''}},language=Go]
newAccessRequest.Link = node.Find // Alteracao do atributo Find do objeto newAccessRequest para o Find do Node
node.SendThroughLink(newAccessRequest) // Envio do objeto newAccessRequest pelo link
node.WaiterWithRequest(accessRequest.Link, node.WaiterChan) //transformacao do Node. Mantem-se o WaiterChan mas altera-se o Link
\end{lstlisting}

\subsection{Cedência do Objeto}
No caso do \emph{Node} ser do tipo ``WAITER\textunderscore TERMINAL'' e receber um pedido ``Access Request'', 
este sofre uma transformação, muda de tipo para ``WAITER\textunderscore WITH\textunderscore REQUEST'' e passou a deter o atributo ``WaiterChan'' (``MyChan'' do \emph{Node} que fez o pedido).

% forma como esta frase está construída pode não estar bem
Esta secção de código é executada concorrentemente (numa \emph{goroutine}) com qualquer outras \emph{goroutines} 
que estejam a ser executadas,
isto para permitir que o \emph{Node} receba outros pedidos,
que os transmita, e que outros comportamentos ou transformações possam ocorrer 
enquanto este espera para ceder o acesso, isto é, enquanto que o \emph{Node} é ``OWNER\textunderscore WITH\textunderscore REQUEST''.


Referente a um caso real, o \emph{Node} transmitiria o objeto pelo \emph{Channel ``WaiterChan''}, quando, por exemplo, 
o acesso a este não fosse mais necessário.
No entanto, por questões de se pretender criar uma simulação deste protocolo, o \emph{Node} decide ceder o acesso ao objeto após um tempo aleatório (entre 1 a 2 segundos)
depois de receber o pedido para o seu acesso.

É executada a primitiva ``defer'' com o método ``Unlock'' do objeto ``Mutex'' para,
quando esta função terminar, o \emph{Mutex} ser desbloqueado, para que outras \emph{goroutines}
possam aceder ao estado atual do objeto.

\begin{lstlisting}[caption={\emph{Node} espera 1 ou 2 segundos antes de ceder o objeto.},language=Go]
	defer Mutex.Unlock() // o ``Mutex'' e desbloqueado quando a execucao deste metodo terminar
	randomSleep := utils.RandomRange(1, 2) // Gera um numero aleatorio, neste caso, 1 ou 2
	time.Sleep(time.Second * time.Duration(randomSleep)) // A \emph{goroutine} espera durante o tempo aleatorio gerado (em segundos)
\end{lstlisting}

De seguida é criado um objeto da classe/tipo ``GiveAccess'' que será transmitido para o \emph{Node} em espera 
através do ``WaiterChan''.

\begin{lstlisting}[caption={Criação do objeto ``accessObject'', da classe ``GiveAccess''},language=Go]
	accessObject := Channels.GiveAccess{WaiterChan: node.WaiterChan}
\end{lstlisting}


Este método (``releaseObj''), contém uma secção crítica,
pois acede ao objeto ``selfNode''. 
O acesso à secção crítica deste método é sincronizada com o uso do \emph{Mutex} ``Mutex'', ou seja,
o acesso ao estado atual do ``selfNode'' só é adquirido por uma \emph{goroutine} de cada vez, para prevenir a alteração do estado
enquanto que o \emph{Node} transmite o acesso ao objeto, 
e para que a transformação (método ``Idle'') ocorra de seguida ao \emph{Node} deixar de ter o acesso ao objeto.

%Referir sendObjectAccess
Quando tiver a possibilidade de aceder à secção crítica, este irá transmitir o acesso do objeto ao \emph{Node} em espera.
De seguida, como já não possui o acesso ao objeto, este sofre um transformação, mudando-se para um \emph{Node}
do tipo ``IDLE'', mantendo o ``Link''.

Como o \emph{Node} transformou-se em ``IDLE'', é inicializada uma \emph{goroutine} que executará o método ``AutoRequest''.
Este método desempenha a função de decidir se o \emph{Node} faz um pedido de acesso. 
%Referir mais à frente o autoRequest
No entanto, este é descrito num capítulo diferente.

De seguida, o procedimento a ser executado neste método é o método ``UpdateVisualization'' da classe ``Node'',
em uma nova \emph{goroutine}.
Este método é usado para atualizar o estado atual do \emph{Node} na visualização.


\begin{lstlisting}[caption={Acesso à secção crítica, transmição do Objeto, transformação em \emph{Node} ``IDLE'', \emph{goroutine} de decisão de pedido, e atualização na visualização},language=Go]
	Mutex.Lock() //Pedido de acesso a seccao critica
	node.SendObjectAccess(accessObject) //Transmissao do objeto, atraves do envio do objeto ``accessObject''
	node.Idle(node.Link) //transformacao em ``IDLE'', mas mantendo o ``Link''
	go node.AutoRequest() // goroutine que decidira se o \emph{Node} faz um pedido de acesso
	go node.UpdateVisualization() // atualiza o estado do Node na visualizacao

\end{lstlisting}


\subsection{Realização de um pedido de acesso}
No caso do \emph{Node} ser do tipo ``IDLE'', este tem a possibilidade de pedir o acesso ao objeto.
Qualquer outro tipo de \emph{Node} não pode fazer pedidos de acesso.

Neste método há acesso ao estado atual do \emph{Node},
logo faz-se uso de um ``Mutex'' para o acesso ser sincronizado.

Como, a partir da visualização e da ``Shell'' do \emph{Node} é possível forçar o \emph{Node} 
a realizar um pedido, quando a \emph{goroutine} acede à secção crítica do método (acesso ao estado atual do \emph{Node})
é verificado se o tipo do \emph{Node} é ``IDLE''.


% Linguagem de Web pode estar incorreta
Caso seja do tipo ``IDLE'', irá ser instanciado um objeto do tipo ``Channels.AccessRequest'', em que o atributo
``Link'' contém o \emph{Channel ``Find''}  do próprio \emph{Node}, ou seja, o \acs{URL} do método
onde o \emph{Node} recebe os pedidos ``AccessRequest'', e
o atributo "GiveAccess" (do tipo ``Channels.GiveAccess''), que contém o \emph{Channel ``MyChan''} do próprio
\emph{Node}, o \acs{URL} do método
onde o \emph{Node} recebe o acesso ao objeto.
Depois da instanciação, é executado o método ``SendThroughLink'' do \emph{Node}, que envia o objeto 
pelo ``Link'' do \emph{Node} para o seu \emph{Child Node}.

O ``Link'' deste objeto servirá para o \emph{Child Node} do \emph{Node} inverter a ligação, isto é, 
para que o \emph{Child Node} possa fazer a ligação de volta para o \emph{Node}.

O atributo ``GiveAccess'' será usado pelo próximo \emph{Node} \emph{Terminal} (quer este seja \emph{Owner} ou \emph{Waiter}), 
para quando esse próximo \emph{Node} obtiver acesso ao objeto, este redirecioná-lo para o \emph{Node} que realizou o pedido.

Como o \emph{Node} realizou um pedido de acesso e espera pelo acesso ao objeto, este transforma-se em 
``WAITER\textunderscore TERMINAl'', deixando de ter ``Link''.

Por último, o \emph{Node} atualiza o seu estado na visualização em uma nova \emph{goroutine}.


\begin{lstlisting}[caption={Método ``Request''},language=Go]
func (node *Node) Request() {
	Mutex.Lock() // Sincronizacao do acesso a seccao critica
	defer Mutex.Unlock() // O metodo ``Unlock'' do objeto ``Mutex'' sera executado caso o metodo ``Request'' termine

	//Existe para evitar:
	//que ou o utilizador faca um request e o node ja mudou de tipo
	//que se faca um request a partir do metodo do Node de pedidos remotos
	if node.Type != IDLE {
		fmt.Printf("Can't request an object if not Idle.")
		return
	}
	fmt.Printf("Requesting.")

	//Instanciacao do pedido de acesso
	accessRequest := Channels.AccessRequest{
		GiveAccess: Channels.GiveAccess{
			WaiterChan: node.MyChan,
		},
		Link: node.Find,
	}

	//Envio do pedido de acesso
	node.SendThroughLink(accessRequest)


	//transfomacao em WaiterTerminal, visto que este espera pelo acesso
	node.WaiterTerminal()

	//atualizacao do estado atual do Node na visualizacao
	go node.UpdateVisualization()
}
\end{lstlisting}


É possível o utilizador provocar a realização do pedido pelo \emph{Node}. Pode ser feito a partir de uma 
``Shell'' que é iniciada com o programa,
ou através da visualização, ao clicar duas vezes no \emph{Node} do grafo correspondente ao \emph{Node} em questão.

No entanto, por questões de simulação do diretório, caso o estado inicial do \emph{Node}
ou este mude de tipo para ``IDLE'', 
é iniciada uma \emph{goroutine} que executa o método ``AutoRequest'' da classe \emph{Node}.

Neste método existe um ciclo ``infinito'', cuja a única condição de saída é o \emph{Node} realizar o pedido.

A cada ciclo é gerado um valor aleatório, que será, em segundos, o tempo que esta \emph{goroutine} irá esperar.

Após a espera, um outro valor aleatório é gerado (0 ou 1),
que indicará se o \emph{Node} irá fazer um pedido (ou seja, se será executado o método ``Request'' da classe ``Node'').


Caso faça o pedido (seja o valor 1), o ciclo irá terminar.
Caso contrário, o \emph{Node} terá de esperar um tempo aleatório até ao próximo ciclo.

\begin{lstlisting}[caption={Método ``AutoRequest''},language=Go]
func (node *Node) AutoRequest() {
	var randomSleep int

	// Ciclo infinito
	for {

		randomSleep = utils.RandomRange(5, 15) // E gerado um numero inteiro aleatorio entre 5 e 15

		fmt.Printf("\nTrying to Request the Object in %d seconds.", randomSleep)


		// A \emph{goroutine} espera durante o valor de ``randomSleep'' (em segundos)
		time.Sleep(time.Second * time.Duration(randomSleep))

		//E gerado um numero inteiro, 0 ou 1.
		//Caso o valor seja 1, o \emph{Node} ira realizar um pedido de acesso e o ciclo termina
		if requests := utils.RandomRange(0, 1); requests > 0 {
			node.Request()
			break
		} else {
			//Caso seja 0, o \emph{Node} ira gerar um numero inteiro aleatorio entre 5 e 20
			cooldown := utils.RandomRange(5, 20)
			fmt.Printf("Didn't request. Retrying in %d seconds.", cooldown)
			// A \emph{goroutine} espera durante o valor de ``cooldown'' (em segundos)
			time.Sleep(time.Second * time.Duration(cooldown))
		}
	}

}
\end{lstlisting}
Este método permite que \emph{Node} realize pedidos em tempo aleatório com uma chance de 50\%,
ou seja, há a possibilidade de o \emph{Node} não realizar um pedido.


\subsection{Receção acesso ao objeto}
Caso o \emph{Node} seja do tipo \emph{WAITER\textunderscore TERMINAL} ou \emph{WAITER\textunderscore WITH\textunderscore REQUEST}
este pode receber o acesso ao objeto.

Quando o \emph{Node} recebe um pedido \emph{GiveAccess} (\emph{Handler} ``myChanRoute'' no ficheiro ``controller.go'') o
método ``ReceiveObj'' da classe \emph{Node} é executado.
O objeto de entrada do método provêm da descodificação dos dados transmitidos pelo \emph{Owner}
que cedeu o acesso ao objeto, isto é, uma desserialização dos dados provenientes de um método \acs{HTTP} ``POST''
num objeto do tipo ``GiveAccess''.


Como neste método, é feito um acesso ao estado atual do \emph{Node} e há transformações, 
o acesso a esta secção crítica é sincronizada com o uso de um \emph{Mutex}.
Para tal, é executado o método ``Lock'' do objeto ``Mutex''.
No fim da execução deste método é necessário desbloquear o ``Mutex'', para tal 
a primitiva ``defer'' é usada, que executará o método ``Unlock'' do objeto ``Mutex''.

Como este programa se trata de uma simulação, este objeto não tem qualquer uso,
no entanto, num caso de uso,
este objeto seria um \emph{Channel} de comunicação com um ficheiro/base de dados, ou qualquer outro
objeto em que o seu acesso seria sincronizado.


Quando o \emph{Node} é ``WAITER\_TERMINAL'', ao receber o acesso ao objeto,
este transforma-se em ``OWNER\_TERMINAL'', pois não tem nenhum outro \emph{Node} em espera.


Quando o \emph{Node} é ``WAITER\_WITH\_Request'', ao receber o acesso ao objeto,
este transforma-se em ``OWNER\_WITH\_REQUES'', pois ainda tem outro \emph{Node} em espera.
%Referir capitulo do release.
Com o \emph{Node} tem outro \emph{Node} à espera do acesso, é inicializada uma \emph{goroutine}
que irá executar o método ``releaseObj'' da classe \emph{Node}.


Ao final, é inicializada uma \emph{goroutine} que executará 
o método ``UpdateVisualization'', para que o estado do \emph{Node}
seja atualizado na visualização.


\begin{lstlisting}[caption={Método ``AutoRequest''},language=Go]

func (node *Node) ReceiveObj(giveAccess Channels.GiveAccess) {
	Mutex.Lock() // Sincronizacao do acesso a seccao critica
	defer Mutex.Unlock() // O metodo ``Unlock'' do objeto ``Mutex'' sera executado caso o metodo ``Request'' termine

	fmt.Printf("Received Access:")
	fmt.Println(giveAccess)
	switch node.Type {
	case WAITER_TERMINAL:
		node.OwnerTerminal()
		break
	case WAITER_WITH_REQUEST:
		node.OwnerWithRequest(node.Link, node.WaiterChan)
		go node.releaseObj()
		break
	}

	go node.UpdateVisualization()

}

\end{lstlisting}

\section{Transformações do \emph{Node}}

% possivelmente adicionar diagrama para ficar mais completo
% por exemplo, IDLE -> recebeu pedido -> IDLE (mas muda o LINK)
% ou, OWNER -> cedeu o objeto -> IDLE(deixou de ter WaiterChan)


Neste capítulo serão descritas as transformações que o \emph{Node}
pode sofrer, tais como as suas implementações.


% mudar o executa qualquer comportamento
O \emph{Node} sofre transformações quando este executa qualquer comportamento, 
no entanto, uma transformação não significa uma mudança de tipo,
mas uma mudança de estado.

Estas são as possíveis transformações que o \emph{Node} pode sofrer:

\begin{figure}[!htb]
\centering
\includegraphics[width=500pt]{state-diagram.png}
\caption{Diagrama de Estados do \emph{Node}}
Nota: O estado inicial do \emph{Node} não está presente porque este pode começar em qualquer estado/tipo.
\end{figure}


O nome dos métodos das transformações provêm do nome to tipo 
para o qual se vai mudar ou manter.


\subsubsection*{Idle}
Se o \emph{Node} é do tipo ``IDLE'' e este recebe um pedido de acesso, após transmitir
o pedido para o seu \emph{Child Node}, sofre a transformação ``Idle'' (mantém o tipo) mas atualiza o \emph{Link} para o \emph{Find} do seu \emph{Parent Node}.
O novo ``Link'' (``NewLink'') é o parâmetro de entrada deste método.

Se o \emph{Node} é do tipo ``OWNER\_WITH\_REQUEST'' mas cedeu o acesso ao objeto, visto que este já não o possui o \emph{Node}
transforma-se em ``IDLE'', mas mantém o \emph{LINK}, isto é, o seu ``Link'' atual é usado como
parâmetro de entrada deste método.

\begin{lstlisting}[caption={Método/transformação ``Idle''},language=Go]
func (node *Node) Idle(newLink string) {
	node.Type = IDLE    //Alteracao do tipo para ``IDLE''
	node.Link = newLink //Atualizacao do ``Link''
	node.Obj = false    //Caso seja ``OWNER\_WITH\_REQUEST'', deixa de ter acesso ao obj
	node.WaiterChan = ""//Caso seja ``OWNER\_WITH\_REQUEST'', deixa de ter o ``Node'' em espera
}
	
\end{lstlisting}


\subsubsection*{WaiterTerminal}

Se o \emph{Node} é do tipo ``IDLE'' e realizar um pedido de acesso,
este sofre a transformação ``WaiterTerminal''.
Como foi o \emph{Node} que realizou o pedido de acesso, este não aponta para nenhum outro \emph{Node} (o ``Link'' passa a vazio/nulo).


\begin{lstlisting}[caption={Método/transformação ``WaiterTerminal''},language=Go]
func (node *Node) WaiterTerminal() {
	node.Type = WAITER_TERMINAL //Alteracao do tipo para ``WAITER\_TERMINAL''
	node.Link = ""       		// Como foi o \emph{Node} quem realizou o pedido, este nao aponta para nenhum outro \emph{Node}
	node.WaiterChan = "" 		//redundante
}
\end{lstlisting}



\subsubsection*{OwnerTerminal}

Se o \emph{Node} é do tipo ``WAITER\_TERMINAL'' e receber o acesso ao objeto, como
não recebeu qualquer pedido, este mantém-se sem ``Link'' ou ``WaiterChan'', 
então sofre a esta transformação, mudando o tipo para ``OWNER\_TERMINAL'', pois tem acesso ao objeto mas não tem qualquer pedido.

\begin{lstlisting}[caption={Método/transformação ``OwnerTerminal''},language=Go]
func (node *Node) OwnerTerminal() {
	node.Type = OWNER_TERMINAL //Alteracao do tipo para ``OWNER\{_}TERMINAL''
	node.Link = ""             
	node.Obj = true			   //Como se transformou em ``OWNER\{_}TERMINAL'' significa que passou a deter o acesso ao objeto
	node.WaiterChan = ""       //Redundante, mas um \emph{Node} deste tipo nao tem \emph{Node} a espera do acesso ao objeto
}
\end{lstlisting}

\subsubsection*{OwnerWithRequest}

Se o \emph{Node} é do tipo ``OWNER\_TERMINAL'' e receber um pedido de acesso, 
como este recebeu um pedido de acesso, o ``Link'' é atualizado e
como este é detentor do acesso ao objeto, o \emph{Node} passa a ter um pedido em espera, logo o ``WaiterChan'' é atualizado para o ``MyChan'' do \emph{Node} em espera.
Então sofre a transformação ``OwnerWithRequest'', mudando o tipo para ``OWNER\_WITH\_REQUEST'', sendo o ``NewLink'' e o ``WaiterChan'' os valores de entrada do método.

Caso o \emph{Node} seja do tipo ``OWNER\_WITH\_REQUEST'', ao receber um pedido de acesso, 
o ``Link'' é atualizado, pois, mesmo sendo o \emph{Node} com acesso ao objeto, este objeto será cedido a outro \emph{Node} e não ao
\emph{Node} que realizou o pedido.

\begin{lstlisting}[caption={Método/transformação ``OwnerWithRequest''},language=Go]
	func (node *Node) OwnerWithRequest(newLink string, waiterChan string) {
		node.Type = OWNER_WITH_REQUEST
		node.Link = newLink
		node.Obj = true
		node.WaiterChan = waiterChan
	}


\end{lstlisting}

\subsubsection*{WaiterWithRequest}

Se o \emph{Node} é do tipo ``WAITER\_TERMINAL'' e receber um pedido de acesso, 
como este recebeu um pedido de acesso, o ``Link'' é atualizado e
como este será detentor do acesso ao objeto, o \emph{Node} passa a ter um pedido em espera, logo o ``WaiterChan'' é atualizado para o ``MyChan'' do \emph{Node} em espera.
Então sofre a transformação ``WaiterWithRequest'', mudando o tipo para ``WAITER\_WITH\_REQUEST'', sendo o ``NewLink'' e o ``WaiterChan'' os valores de entrada do método.

Caso o \emph{Node} seja do tipo ``WAITER\_WITH\_REQUEST'', ao receber um pedido de acesso, 
o ``Link'' é atualizado, pois, mesmo que este \emph{Node} terá o acesso ao objeto, este objeto será cedido a outro \emph{Node} (do primeiro pedido que transformou o \emph{Node} em` `WAITER\_WITH\_REQUEST'' ) 
e não ao
\emph{Node} que realizou este pedido.

\begin{lstlisting}[caption={Método/transformação ``WaiterWithRequest''},language=Go]
	func (node *Node) WaiterWithRequest(newLink string, waiterChan string) {
		node.Type = WAITER_WITH_REQUEST
		node.Link = newLink
		node.WaiterChan = waiterChan
	}
	
\end{lstlisting}

\section{Comunicação entre Nodes}
% Explicar o uso de HTTP - industry standard

Neste capítulo serão tratadas as conexões que os \emph{Nodes} fazem entre si,
Como referido anteriormente, é feito uso do protocolo \acs{HTTP} nas ligação/pedidos entre \emph{Nodes}, pois este é um ``industry standard'' (ou seja, o protocolo mais usado neste tipo de sistemas).
Para tal, cada \emph{Node} inicia um servidor \acs{HTTP} que espera pela entrada de pedidos de HTTP, isto é, espera que outros \emph{Nodes} transmitam pedidos do tipo ``AccessRequest'' e ``GiveAccess''.
A implementação do servidor \acs{HTTP} está presente no módulo ``controller'' (no ficheiro ``controller.go'').

No entanto, também foram implementados métodos para permitir ao \emph{Node} a realização de pedidos, ou seja, de poder enviar informação para outros \emph{Nodes}.
A implementação destes pedidos \acs{HTTP} está presente no módulo ``Node'' (no ficheiro ``NodeCommunications.go'').


% acrescentar aqui mais alguma coisa

\subsection{Servidor \acs{HTTP}}
Após a inicialização do programa do \emph{Node}, é inicializado o servidor \acs{HTTP}, executando a função ``StartServer'', em que é criado um objeto do tipo ``Router'' (roteador),  
no qual são registados os vários caminhos e \emph{Handlers}(manipuladores) destes caminhos. Isto é, são registados os métodos deste servidor e as funções que serão executadas
caso sejam feitos pedidos em cada um desses métodos.

Os métodos e \emph{Handlers} registados são:


\begin{description}
	\item [/find] findRoute - Saida do \emph{Channel ``Find''} do \emph{Node}
	\item [/myChan] myChanRoute - Saida do \emph{Channel ``MyChan''} do \emph{Node}
	\item [/remoteRequest] remoteRequest - Metodo usado na visualizacao para forcar o \emph{Node} a realizar um pedido accessRequest
\end{description}

%Mudar isto
Por fim, é executado a função ``ListenAndServe'' do módulo ``http'', que escuta por pedidos de \emph{HTTP} de entrada.
Os parâmetros de entrada deste método são o endereço do \emph{Node} (``MyAddress'') e o ``Router'' instanciado.


\begin{lstlisting}[caption={Método/transformação ``WaiterWithRequest''},language=Go]
	r := mux.NewRouter() //Instanciacao do objeto r da classe ``Router''

	// Registo dos metodos e \emph{Handlers}
	r.HandleFunc("/find", findRoute).Methods("POST")
	r.HandleFunc("/myChan", myChanRoute).Methods("POST")
	r.HandleFunc("/remoteRequest", remoteRequest).Methods("GET")


	// Inicializacao do servidor
	if err := http.ListenAndServe(selfNode.MyAddress, r); err != nil {
		log.Fatal(err) 				
	/* Caso ocorra um erro (err != nil), a execucao e terminada, 
		o programa termina a execucao e e mostrado o erro.
	*/
}
\end{lstlisting}




%Mudar isto
De seguida, serão descritos os métodos e as funções executadas:

\subsubsection*{/find}
Este método equivale à saída do channel ``Find'' (referido na Especificação).
Quando um \emph{Node} transmite um pedido de ``AccessRequest'' para outro \emph{Node},
esta transmissão é feita através de um pedido \acs{HTTP} ``POST'', em que no corpo 
do pedido está incluído a informação do pedido ``AccessRequest'', no formato ``JSON''.

Este método aceita pedidos \acs{HTTP} ``POST''.

Neste \emph{Handler}, é feita uma desserialização do corpo do pedido de ``JSON'' para um objeto
do tipo ``AccessRequest'', para este ser usado como parâmetro de entrada no método ``HandleFind''
da classe ``Node''.

No final da execução deste \emph{Handler}, é feita uma resposta para o \emph{Node} que transmitiu o pedido, com o conteúdo ``Successful''
e é fechado o corpo do pedido, usando o método ``Close'' do objeto ``Body'' do pedido ``r'',
através do uso da primitiva ``defer'', que garante a execução deste método após a execução do ``Handler terminar''.

\begin{lstlisting}[caption={\emph{Handler} ``findRoute'' do método ``/find''},language=Go]
func findRoute(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close() //defer garante que este procedimento e executado quando a execucao deste ``Handler'' termina

	//definicao que o tipo de conteudo do corpo tem o formato ``JSON''
	w.Header().Set("Content-Type", "application/json")

	// desserializacao do corpo para um objeto do tipo ``AccessRequest''
	var accessRequest Channels.AccessRequest
	_ = json.NewDecoder(r.Body).Decode(&accessRequest)

	fmt.Printf("\nGot a find request")
	fmt.Printf("\n%s", utils.StructToString(accessRequest))

	// execucao do metodo HandleFind do node
	selfNode.HandleFind(accessRequest)

	json.NewEncoder(w).Encode("Successful") // Resposta ao ``Node'' que realizou o pedido \acs{HTTP}

}

\end{lstlisting}


\subsubsection*{/myChan}
Este método equivale à saída do channel ``MyChan'' (referido na Especificação).
Quando um \emph{Node} transmite um pedido de ``GiveAccess'' para outro \emph{Node},
esta transmissão é feita através de um pedido \acs{HTTP} ``POST'', em que no corpo 
do pedido está incluído a informação do pedido ``GiveAccess'', no formato ``JSON''.

Este método aceita pedidos \acs{HTTP} ``POST''.

Neste \emph{Handler}, é feita uma desserialização do corpo do pedido de ``JSON'' para um objeto
do tipo ``GiveAccess'', para este ser usado como parâmetro de entrada no método ``ReceiveObj''
da classe ``Node''.

No final da execução deste \emph{Handler}, é feita uma resposta para o \emph{Node} que transmitiu o pedido, com o conteúdo ``Successful''
e é fechado o corpo do pedido, usando o método ``Close'' do objeto ``Body'' do pedido ``r'',
através do uso da primitiva ``defer'', que garante a execução deste método após a execução do ``Handler terminar''.

\begin{lstlisting}[caption={\emph{Handler} ``myChanRoute'' do método ``/myChan''},language=Go]
func myChanRoute(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close() //defer garante que este procedimento e executado quando a execucao deste ``Handler'' termina

	//definicao que o tipo de conteudo do corpo tem o formato ``JSON''
	w.Header().Set("Content-Type", "application/json")

	// desserializacao do corpo para um objeto do tipo ``GiveAccess''
	var giveAccess Channels.GiveAccess
	_ = json.NewDecoder(r.Body).Decode(&giveAccess)

	fmt.Printf("\nGot Access To The Object!")
	fmt.Printf("\n%s", utils.StructToString(giveAccess))

	// execucao do metodo ReceiveObj do node
	selfNode.ReceiveObj(giveAccess)

	json.NewEncoder(w).Encode("Successful") // Resposta ao ``Node'' que realizou o pedido \acs{HTTP}

}

\end{lstlisting}

\subsubsection*{/remoteRequest}

Este método não tem qualquer uso dentro diretório.
É apenas utilizado para forçar o \emph{Node} a realizar um pedido a partir da visualização (ou qualquer outra forma de realização de pedidos \acs{HTTP}).

O método ``Request'' da classe \emph{Node} é executado, este método é usado para a realização de um pedido de acesso.
Por último, é feita uma resposta ao ``Client'' que realizou o pedido \acs{HTTP} e a conexão é terminada com 
o o fecho do corpo do pedido, usando o método ``Close'' do objeto ``Body'' do pedido ``r''.

\begin{lstlisting}[caption={\emph{Handler} ``myChanRoute'' do método ``/myChan''},language=Go]
	func remoteRequest(w http.ResponseWriter, r *http.Request)  {
		defer r.Body.Close() //defer garante que este procedimento e executado quando a execucao deste ``Handler'' termina
		selfNode.Request() //metodo de realizacao de pedidos AccessRequest
		json.NewEncoder(w).Encode("Successful") // Resposta ao ``Client'' que realizou o pedido
	}
	

\end{lstlisting}
% Explicar ficheiro controller.go - recebe - servidor de HTTP
	% inicialização do servidor
	% channel find - findRoute
	% channel myChan - myChanRoute
	% remoteRequest

\subsection{Pedidos \acs{HTTP} do \emph{Node}}
% Mudar a introdução
O \emph{Node} tem a possibilidade de realizar pedidos \emph{HTTP}, todos eles do tipo ``POST''.

Para tal foram definidos 3 métodos diferentes, em que todos executam a mesma função ``sendDataTo''.

Esta função ``sendDataTo'' é polimórfica, pois o segundo parâmetro de entrada é do tipo ``interface'', isto é, o segundo parâmetro
de entrada desta função pode ser de qualquer tipo (mas que seja possível a sua serialização para o formato ``JSON'').

O primeiro parâmetro é o \acs{URL} para o qual irá ser enviado o pedido ``POST''.

Na existência de falhas no envio do pedido, são feitas no máximo 4 tentativas de envio, com um tempo de 4 segundos de espera entre cada tentativa.
\begin{lstlisting}[caption={\emph{Handler} ``myChanRoute'' do método ``/myChan''},language=Go]


// o parametro ``data'' pode ser de qualquer tipo/classe
func sendDataTo(toURL string, data interface{}) {

	//serializacao da informacao ``data'' para uma string
	message, err := json.Marshal(data)
	if err != nil {
		log.Fatal(err)
	}

	// Contador de tentativas efetuadas
	retries := 0

	for retries < maxRetries {

		resp, err := http.Post(toURL, "application/json", bytes.NewBuffer(message))

		//Caso existam falhas no envio
		if err != nil {
			fmt.Fprintln(os.Stderr, err)

			// incrementacao do valor de tentativas efetuadas
			retries++
			// a \emph{goroutine} espera durante 4 segundos
			time.Sleep(time.Second * time.Duration(4))

			continue
		}

		_, err = ioutil.ReadAll(resp.Body)
		if err != nil {
			resp.Body.Close()
			log.Fatal(err)
		}

		//Fecho do corpo do pedido e da conexao
		resp.Body.Close()
		break

	}

}

\end{lstlisting}


% Melhorar isto
Os três tipos de pedidos (\acs{HTTP}) possíveis que o \emph{Node} pode realizar são:

\subsubsection*{SendThroughLink}
Envia um pedido do tipo ``AccessRequest'' para o seu \emph{Child Node}.
Tem como parâmetro de entrada um objeto da classe ``AccessRequest''.
Executa a função ``sendDataTo'' como valores de entrada o ``Link'' do \emph{Node}, isto é, o ``Find'' do seu \emph{Child Node}
e o objeto da classe ``AccessRequest''.

\begin{lstlisting}[caption={Método ``SendThroughLink''},language=Go]
func (node *Node) SendThroughLink(accessRequest Channels.AccessRequest) {
	go sendDataTo(node.Link, accessRequest)
}
\end{lstlisting}


\subsubsection*{SendObjectAccess}
Envia um pedido do tipo ``GiveAccess'' para o \emph{Node} que espera pelo acesso ao objeto.
Tem como parâmetro de entrada um objeto da classe ``GiveAccess''.
Executa a função ``sendDataTo'' como valores de entrada o ``WaiterChan'' do \emph{Node}, isto é, o ``MyChan'' do \emph{Node} que espera pelo acesso ao objeto
e o objeto da classe ``GiveAccess''.

\begin{lstlisting}[caption={Método ``SendObjectAccess''},language=Go]
func (node *Node) SendObjectAccess(giveAccess Channels.GiveAccess) {
	go sendDataTo(node.WaiterChan, giveAccess)
}

\end{lstlisting}

\subsubsection*{UpdateVisualization}
Atualiza o estado do \emph{Node} na visualização.
Executa a função ``sendDataTo'' como valores de entrada o ``VisAddress'' do \emph{Node}, isto é, o \acs{URL} do método da visualização de atualização de dados
e o objeto da classe ``Node''.

\begin{lstlisting}[caption={Método ``UpdateVisualization''},language=Go]
func (node *Node) UpdateVisualization(){
	go sendDataTo(node.VisAddress, node)
}
\end{lstlisting}


\section{Classes de \emph{Channels}}
% Melhorar a introdução
Neste capítulo serão descritos os ``Channels''/Pedidos utilizados pelos \emph{Nodes}, sendo estes ``AccessRequest'' e ``GiveAccess''.

As ``Struct'' destes estão definidas no módulo ``Channels'', no ficheiro \textbf{channels.go}.


\subsection{GiveAccess}
%Aumentar a descrição
Esta classe encapsula o \emph{Channel ``MyChan''} do \emph{Node} realizou o pedido de acesso.
Num caso real, este também incluiria um \emph{Channel} que daria acesso ao objeto, ou o próprio objeto, no entanto
como nesta implementação se pretende criar uma simulação deste protocolo, esse atributo não é necessário.

\begin{lstlisting}[caption={Método ``UpdateVisualization''},language=Go]

type GiveAccess struct {
	WaiterChan string `json:"waiterChan"`
}

\end{lstlisting}


\subsection{AccessRequest}
Esta classe encapsula um pedido de acesso ao objeto. Os atributos são o ``Link'', que contém o ``Find'' do \emph{Node} que transmitiu o pedido e 
o ``GiveAccess'' instanciado pelo \emph{Node} que fez o pedido.

Ou seja, o atributo ``GiveAccess'' mantém-se entre transmissões dos \emph{Nodes} mas o atribuição ``Link'' é alterado em cada \emph{Node} para o 
seu \emph{Channel ``Find''}.

\begin{lstlisting}[caption={Método ``UpdateVisualization''},language=Go]
type AccessRequest struct {
	GiveAccess GiveAccess `json:"giveAccess"` // #2
	Link       string     `json:"link"`       // #1
}
\end{lstlisting}




\section{Implementação da Visualização}

\subsection{Servidor \acs{HTTP}}
% router
% definição do filesystem para aceder a ficheiros estáticos

% definição dos métodos da API e Handlers

\subsection{Servir ficheiros estáticos}
% método root /

\subsection{Atualização da visualização}
% método updateState /updateState
% Cada Node envia o seu estado atual
% o acesso ao Map que mantém todos os dados é 
\subsection{Renderização da visualização}
% método data /data
% grande parte do ficheiro de JS não é relevante



\subsection{Queue}
% Método Queue

% como os dados são atualizados
% como os dados são passados para a página
% como os dados são demonstrados no grafo
% como a queue é formada
% como o histórico é formado

\section{Conclusões}
